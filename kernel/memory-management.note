

#内存地址,有三种
	1 逻辑地址，Logical address,由16 bit的Segment selector 和32 bit的段内偏移量组成。
那什么是段呢?简单说来就是一个应用程序被切成一段一段的，比如代码段、数据段、栈段。当回忆过去，我总是能想起那些错过我，或是我错过的女生，除此之外还有在进程的用户内存空间布局中的几个段。其实这些段是一会儿事，可是也存在不同，即属于不同的地址空间，前者是逻辑地址空间logical address space，后者是虚拟地址空间virtual address space。在两个不同的空间中存在着几乎相同的副本，另外我们还知道逻辑地址要经过硬件的分段单元最终转换为虚拟地址，所以在linux当中分段存在价值不大，变相地被linux弃用了,方法很简单就是把逻辑空间的代码段和数据段的基址都设为0,换句话说，就是所有段的地址都和虚拟地址空间一样了，因为段内偏移量可是32位的。在ULK3上，作者说相对于分页来说分段有点多余，换句话说就是分页已经对进程的物理地址空间进行划分了，没有必要在用分段对进程的虚拟地址空间再次划分，按大连话就是你忙不忙到人呀！虽然linux可以变相地不使用分段机制，但是人家毕竟是存在的，而且还是硬件般的存在，所以不能完全无视呀。段的样子是由段描述符描述的，比如这个段的起始地址、偏移量最大值、权限什么的都在这个段描述符中。段描述符存储在大名鼎鼎的GDT全局描述符表当中。这里全局的意思是每个cpu只有一个GDT。这个GDT表都存什么呢？主要就是各种数据段和代码段的描述符，因为他是描述符表嘛，人家就是吃这口饭的。在GDT这张表中有很多的段描述符，我们怎么找到一个程序的代码段或是数据段描述符呢？这就要用到标题中的Segment selector。如果说GDT是一个数组那么Segement selecter 就是下标。我们使用cs 和ds 这两个寄存器来存储数据段和代码段的Segementor selector。程序分段是Intel 捣鼓出来的，为什么要分段呢？16 bit cpu时代Intel发明出来用16 bit的logical 段基址和16 bit的logical段内偏移凑出20 bit的线性地址也就是虚拟地址，从而加大可用内存数量。
我们把梳理下思路，在很久以前当intel需要更大内存时，蛋疼的分段出现了就有了段，于是段描述符也跟着出现了，进而用于保管段描述符的GDT也诞生，而段选择符Segment selector为了找到GDT中的段描述符也出现了，又因为没有分段的必要性，被变相linux弃用了。
解决	
	2 线性地址Linear address or虚拟地址 Virtual address，由数量众多的page页组成。
看到逻辑地址，想到分段。看到虚拟地址，想到分页。分页是为了提高效率。
	3 物理地址Physical address，由数量众多的page frame页框
物理地址，就是实际的内存RAM的地址。我们来整理下linux当中常见的“空间”，当然要无视逻辑地址空间，好开始。
虚拟地址空间：在32-bit 的cpu下，对于每个进程来说都有4GB的虚拟地址空间。36-bit cpu下 启用PAE物理地址扩展机制后，虚拟地址空间仍然是4GB，那么这个36 -bit的cpu，到底改变了什么？我们知道一个进程的4GB地址空间分为用户态3GB 和内核态1GB，所有进程都有一样的1GB内核态。每个进程用户态的3GB地址空间所使用的内存都是由页表映射而来。唯一不需要页表映射就可以访问的内存是，内核态1GB当中的前896MB，这896MB和物理内存建立了线性映射，提问，什么是线性映射？对于进程的内核态也就是内核本身来说要访问这896MB虚拟内存之外的虚拟内存也需要使用页表映射到实际的物理内存。下面PAE登场，在PAE机制下虚拟地址空间仍是4GB，换句话，就是4GB，3GB，1GB，896MB这些规定仍然没变，因为映射的关系，内核态1GB当中除了896MB之外的128MB的虚拟地址空间可以在不同时刻映射到不同物理内存当中，最多可以映射到64GB物理内存而不是原来的4GB。
物理地址空间：即RAM内存，x86架构下通常有三种大小规格。32-bit cpu 最大访问4GB的内存。36-bit cpu 最大访问64GB内存。而64-bit cpu可以访问到2的64次放，非常巨大，linux只使用48bit 即256TB，这么大的内存，很长一段时间内48 bit的内存空间绝对够用。
I/O端口空间：和内存的物理地址空间类似，它是由各种设备上的内存和寄存器组成的空间。
I/O内存空间：这个就是cpu的寻址空间，包括了内存和设备上内存和寄存器。说明一下，I/O端口空间和I/O内存空间是独立的，设备的内存和寄存器可以分别映射的这两个空间，cpu使用不同的访问指令访问他们。





