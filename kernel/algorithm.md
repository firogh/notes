---
tags: kernel
title: Algorithms and data structues in Linux kernel
date: 2015-05-27 12:42:12
category: kernel
---

# Reference
[Core algorithms deployed](http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed#)

# Introduction 
说实话, 这年头想要做点学问还是需要点定力的.
就拿内核中的数据结构与算法来说, 也不是说, 别人来了句, 我靠, awesome!
你也过来瞅两眼, 也能心生感慨, what the fuck! how can this be true?
我说的定力, 不是两耳闻听窗外事, 一心还读圣贤书!而是思维的能力.
这是见真章的地方, 不动脑子是玩不转的, 最终浮于表面, 不得所获.

kfifo 和lock-less list 是kernel中两个基础的数据结构, 用得也不多.
说实在的这些都不是什么特别难的技术, 但是这种较真的东西使最能考察一个人的能力的.
什么能力? 写个链表, 队列谁不会? 这里考察的是人的创造力!
所谓创造力就是一种组合的能力.拆分也是一种组合.

今天, 我们来聊一聊算法. 数据结构在我看来是算法的一种.
到底是什么呢? algorithm这个词来自中古拉丁文algorismus音译自一位阿拉伯数学家的名字
al-Khwarizmi, 这只是一个姓, 类似中文赵钱孙李, al-Khwarizmi这个姓表示
[花剌子模](https://zh.wikipedia.org/wiki/%E8%8A%B1%E5%89%8C%E5%AD%90%E6%A8%A1)地方的人.数学家的全名是Abū ‘Abdallāh Muḥammad ibn Mūsā al-Khwārizmī
花剌子模有太阳升起之地之意源于这个国家被大量沙漠围住, 气候干燥. 而lowland, 则是因为其海拔很低.
显然, 这不是我们关心的算法本质. 那么, 为什么欧洲人会把al-Khwarizmi, 作为算法的称谓呢?
al-Khwarizmi向西方引入了10进制计数法和代数. 同时他的名字慢慢被赋予了现代算法的涵义.
也就是algorithm的涵义是慢慢衍生出来的.
那我们能否给算法下一个定义呢:

	An informal definition could be "a set of rules that precisely defines a sequence of operations."
简单说, 就是一个执行序列. 这有点太概况了.我们需要一个更精准的定义.
同时, 我并不把他限制在计算机科学内.
如果你读过石里克的[普通认识论](http://book.douban.com/subject/1443472/)你就会知道, 光的定义也是一波三折.
所谓的定义, 实际上事物某些属性的集合!
我们来考察算法的属性.诚如前面的定义算法是一个执行序列.
那么算法的表现形式呢? 他是抽象的, 根植于人类的思维逻辑当中. 而人的逻辑是通过
语言表述的.所以算法的重要属性就是他是语言这种形式表现出来的.
所以我们的定义, 变成一个被执行的语言序列.
我们还是不满足, 你难道就让我去用这么一句话, 去面对面试时候的各种算法题吗?
现在我们从算法解决的问题入手? 这是算法的目的. 我的目的是让算法更加的通俗易懂.
不是让人们说道, 算法就会去向排序, 二叉树. 这跳跃太大了, 在算法的基础定义和实际的算法之间,
还有一些内容, 值得我们挖掘.我们考察排序和二叉树, 这两种算法:

	A sorting algorithm is an algorithm that puts elements of a list in a certain order.
从排序算法的定义中, 我们窥探到了算法的一些本质属性. 使对象具备某种属性.这里面有序就是一种属性.
再来看二叉树:

	a binary tree is a tree data structure in which each node has at most two children, 
	which are referred to as the left child and the right child.
无论是二叉树, 还是排序, 我们都能感受到, 算法在展现一种魔法, 使用元素的建立某种空间结构/关系.
也就是说, 我们的思维本身就具有某种抽象意义上的空间搬运能力.我门知道空间关系, 在确定了个提之后
是十分清晰的前后左右上下, 这样, 现在我们能进一步的定义算法:

	算法是使对象具备某种空间关系的而被执行的语言序列
这里的对象显然是语言层面的.我们的定义是否恰当能呢? 是否所有的算法都是让对象具备某种空间关系吗?
在比如找到两个数组中相同的元素, 类似常见的字符串查找, 也是不具有所谓的空间的关系, 而是更为抽象的序关系.
什么是序关系? c语言的比较操作符 < > = 这些都是序关系, 准确说是二元关系.
而空间关系, 我们也可以通过坐标抽象, 得到数学上的需关系.显然有些时候空间关系更为生动, 但你知道这可以
用order theory解释.
作为最古老的算法gcd, 最大公约数, 不是上面的所谓的序关系结构. 他就是一种纯粹的数学定义.
这个算法的目的不在是一个多个元素的整体了, 只是单独挑出符合性质的其中的元素. 但是在界gcd问题时
我们依然可以把他转换为同过序关系得到答案.而欧几里得的方法, 确不是用gcd定义的方法解的而是用求余的
方法. 求余依然是序的关系, 只不过方法不一样, 一个循环比较一个是通过求余加速了答案的发现.
我们现在姑且认为, 所有算法的最终结果都是为了得到一种序的关系.
我们现在来整理下算法的定义:

	算法是使对象具备某种序关系的而被执行的语言序列
我们现在来考察, 算法的对象, 我们能感觉到他可以具有任何形态.
暂略.
我们来看算法的核心-- 语言序列, 对象, 执行的目的某种序关系, 三者之间的关系.
同时为了更好的理解语言序列.
我们先探索一些重要且常见的思路, 也就是语言序列的patterns.
我们学过的一些算法, 可以用递归的方式解, 而且很简单. 比如二叉树翻转, 二叉树遍历,
快排等等, 作为一种解问题的思路也就是, 语言序列的模式. 我们要彻底的搞懂倒地什么才是
递归? 为什么递归可以很好的解决问题.
![递归图](https://upload.wikimedia.org/wikipedia/commons/thumb/6/62/Droste.jpg/220px-Droste.jpg)
就是这种感觉, 你总能看到自己的样子, 每个尽头. 可是计算机的递归是有终止条件, 否则程序就跑飞了.
所以, 无论脑洞多大, 都要想到如何停止递归调用.
就和我们写个for循环for (i=0; i < 10; i++) 一个道理, 本质都是在重复. 递归定义:

	递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。
通俗说函数调用自身, 都是递归.一个合格的递归, 有终止条件和非终止条件.非终止条件必须可以通过递归变成终止条件.
现在我们来看下两类经典的算法排序和二叉树.先说二叉树, 各种遍历啊翻转都是用递归实现的.
先不考虑递归的问题, 就比方说我们要把二叉树的所有点都打印出来, 随便打不要管什么深度广度中序啊. 你会怎么办?
一个for循环把所有最left都打出来了, 其他点呢? 没出来.怎么办?为什么二叉树这么难处理啊?
我们之前打印数组or链表一个循环就ok了. 二叉树的和他们的区别是一个点有2个后继.
那么2个后继对我们造成什么影响. for通过单个指针只能得到线性的关系. 那如何得到树式的关系呢?
我们可以从最简单的开始考察空树, 1,2层的树都好办. 3层呢, 就不好办了? 怎么不好办了.
如果我们知识在白板上把每个节点, 画个对号, 就算输出的话, 我们很轻松, 就画完了.
可是在计算机内部, 比如我们现在100层的树我们在left子树上输出, 我们就没有办法知道丛root开始
的right子树的信息了, 我们一条路走到黑, 回不去了. 我门必要track住所谓的right节点的信息.
这很明显, 咋么track住呢?还是以3层树为例我们可以轻而易举的输出上面两层.
如果按层输出, 我们输出当前node把子nodes存到queue里面, 每次都这么干. 我们track住了其他节点的信息了
而链表这种线性结构则是自身就可以track住后继节点的信息, 这就是差别, 多了一个node我们就要
多个地方存他, 在我们的场景你都不需要关系存的顺序, 因为我们就是随便输出, 全输出就可以了.
回过头, 我们来看, 这个解法和递归之间的关系. 只要最终能终止就可以用递归解, 我们这个问题能吗?
显然可以, 停在最底层节点.
void bin_recur(node)
{
	//这是内核的标准风格
	if(!node)
		return

	print(node);
	bin_recur(node->left);
	bin_recur(node->right);
}

完了这就是我们的随意树遍历法, 记住我们只要求输出全部节点就ok了. 至于, node之间的关系, 就随他去吧.哈哈.
无论递归多么简洁, track nrightnode信息一个也不能少, 知识没有眼睛的计算机的眼睛, 就好像盲人的盲文一样.
这个递归的和我们的for循环的结果不一样.不用queue用stack结果就一直了.
广度优先不可以用递归形式, 这是我们知道的第一个不能用递归解的问题.
1. 接下来我们聊3个问题, 什么问题不能用递归解
2. 递归 和非递归如何转换
3. 结合排序算法探讨递归.








看几个个算法:二叉树翻转, 二叉树遍历, buddy system, page 







