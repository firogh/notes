// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msgprotobuf.proto

#ifndef PROTOBUF_msgprotobuf_2eproto__INCLUDED
#define PROTOBUF_msgprotobuf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace weiyun {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msgprotobuf_2eproto();
void protobuf_AssignDesc_msgprotobuf_2eproto();
void protobuf_ShutdownFile_msgprotobuf_2eproto();

class MsgHead;
class MsgBody;
class ReqMsgBody;
class RspMsgBody;
class ClientFileTransQueryMsgReq;
class ClientFileTransQueryMsgRsp;

enum MsgHead_Type {
  MsgHead_Type_ReqMsg = 1,
  MsgHead_Type_RspMsg = 2
};
bool MsgHead_Type_IsValid(int value);
const MsgHead_Type MsgHead_Type_Type_MIN = MsgHead_Type_ReqMsg;
const MsgHead_Type MsgHead_Type_Type_MAX = MsgHead_Type_RspMsg;
const int MsgHead_Type_Type_ARRAYSIZE = MsgHead_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgHead_Type_descriptor();
inline const ::std::string& MsgHead_Type_Name(MsgHead_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgHead_Type_descriptor(), value);
}
inline bool MsgHead_Type_Parse(
    const ::std::string& name, MsgHead_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgHead_Type>(
    MsgHead_Type_descriptor(), name, value);
}
enum Cmd {
  ClientFileTransQueryMsg = 1001
};
bool Cmd_IsValid(int value);
const Cmd Cmd_MIN = ClientFileTransQueryMsg;
const Cmd Cmd_MAX = ClientFileTransQueryMsg;
const int Cmd_ARRAYSIZE = Cmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* Cmd_descriptor();
inline const ::std::string& Cmd_Name(Cmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    Cmd_descriptor(), value);
}
inline bool Cmd_Parse(
    const ::std::string& name, Cmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Cmd>(
    Cmd_descriptor(), name, value);
}
// ===================================================================

class MsgHead : public ::google::protobuf::Message {
 public:
  MsgHead();
  virtual ~MsgHead();
  
  MsgHead(const MsgHead& from);
  
  inline MsgHead& operator=(const MsgHead& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgHead& default_instance();
  
  void Swap(MsgHead* other);
  
  // implements Message ----------------------------------------------
  
  MsgHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgHead& from);
  void MergeFrom(const MsgHead& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgHead_Type Type;
  static const Type ReqMsg = MsgHead_Type_ReqMsg;
  static const Type RspMsg = MsgHead_Type_RspMsg;
  static inline bool Type_IsValid(int value) {
    return MsgHead_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MsgHead_Type_Type_MIN;
  static const Type Type_MAX =
    MsgHead_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MsgHead_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MsgHead_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MsgHead_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MsgHead_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int64 uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::int64 uin() const;
  inline void set_uin(::google::protobuf::int64 value);
  
  // required uint32 seq = 2;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);
  
  // optional .weiyun.MsgHead.Type type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::weiyun::MsgHead_Type type() const;
  inline void set_type(::weiyun::MsgHead_Type value);
  
  // optional int32 cmd = 4;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 4;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 retcode = 101;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 101;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);
  
  // optional string retmsg = 102;
  inline bool has_retmsg() const;
  inline void clear_retmsg();
  static const int kRetmsgFieldNumber = 102;
  inline const ::std::string& retmsg() const;
  inline void set_retmsg(const ::std::string& value);
  inline void set_retmsg(const char* value);
  inline void set_retmsg(const char* value, size_t size);
  inline ::std::string* mutable_retmsg();
  inline ::std::string* release_retmsg();
  
  // @@protoc_insertion_point(class_scope:weiyun.MsgHead)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_retmsg();
  inline void clear_has_retmsg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 uin_;
  ::google::protobuf::uint32 seq_;
  int type_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 retcode_;
  ::std::string* retmsg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msgprotobuf_2eproto();
  friend void protobuf_AssignDesc_msgprotobuf_2eproto();
  friend void protobuf_ShutdownFile_msgprotobuf_2eproto();
  
  void InitAsDefaultInstance();
  static MsgHead* default_instance_;
};
// -------------------------------------------------------------------

class MsgBody : public ::google::protobuf::Message {
 public:
  MsgBody();
  virtual ~MsgBody();
  
  MsgBody(const MsgBody& from);
  
  inline MsgBody& operator=(const MsgBody& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgBody& default_instance();
  
  void Swap(MsgBody* other);
  
  // implements Message ----------------------------------------------
  
  MsgBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgBody& from);
  void MergeFrom(const MsgBody& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .weiyun.ReqMsgBody ReqMsg_body = 1;
  inline bool has_reqmsg_body() const;
  inline void clear_reqmsg_body();
  static const int kReqMsgBodyFieldNumber = 1;
  inline const ::weiyun::ReqMsgBody& reqmsg_body() const;
  inline ::weiyun::ReqMsgBody* mutable_reqmsg_body();
  inline ::weiyun::ReqMsgBody* release_reqmsg_body();
  
  // optional .weiyun.RspMsgBody RspMsg_body = 2;
  inline bool has_rspmsg_body() const;
  inline void clear_rspmsg_body();
  static const int kRspMsgBodyFieldNumber = 2;
  inline const ::weiyun::RspMsgBody& rspmsg_body() const;
  inline ::weiyun::RspMsgBody* mutable_rspmsg_body();
  inline ::weiyun::RspMsgBody* release_rspmsg_body();
  
  // @@protoc_insertion_point(class_scope:weiyun.MsgBody)
 private:
  inline void set_has_reqmsg_body();
  inline void clear_has_reqmsg_body();
  inline void set_has_rspmsg_body();
  inline void clear_has_rspmsg_body();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::weiyun::ReqMsgBody* reqmsg_body_;
  ::weiyun::RspMsgBody* rspmsg_body_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msgprotobuf_2eproto();
  friend void protobuf_AssignDesc_msgprotobuf_2eproto();
  friend void protobuf_ShutdownFile_msgprotobuf_2eproto();
  
  void InitAsDefaultInstance();
  static MsgBody* default_instance_;
};
// -------------------------------------------------------------------

class ReqMsgBody : public ::google::protobuf::Message {
 public:
  ReqMsgBody();
  virtual ~ReqMsgBody();
  
  ReqMsgBody(const ReqMsgBody& from);
  
  inline ReqMsgBody& operator=(const ReqMsgBody& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMsgBody& default_instance();
  
  void Swap(ReqMsgBody* other);
  
  // implements Message ----------------------------------------------
  
  ReqMsgBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqMsgBody& from);
  void MergeFrom(const ReqMsgBody& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .weiyun.ClientFileTransQueryMsgReq ClientFileTransQueryMsgReq_body = 1001;
  inline bool has_clientfiletransquerymsgreq_body() const;
  inline void clear_clientfiletransquerymsgreq_body();
  static const int kClientFileTransQueryMsgReqBodyFieldNumber = 1001;
  inline const ::weiyun::ClientFileTransQueryMsgReq& clientfiletransquerymsgreq_body() const;
  inline ::weiyun::ClientFileTransQueryMsgReq* mutable_clientfiletransquerymsgreq_body();
  inline ::weiyun::ClientFileTransQueryMsgReq* release_clientfiletransquerymsgreq_body();
  
  // @@protoc_insertion_point(class_scope:weiyun.ReqMsgBody)
 private:
  inline void set_has_clientfiletransquerymsgreq_body();
  inline void clear_has_clientfiletransquerymsgreq_body();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::weiyun::ClientFileTransQueryMsgReq* clientfiletransquerymsgreq_body_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msgprotobuf_2eproto();
  friend void protobuf_AssignDesc_msgprotobuf_2eproto();
  friend void protobuf_ShutdownFile_msgprotobuf_2eproto();
  
  void InitAsDefaultInstance();
  static ReqMsgBody* default_instance_;
};
// -------------------------------------------------------------------

class RspMsgBody : public ::google::protobuf::Message {
 public:
  RspMsgBody();
  virtual ~RspMsgBody();
  
  RspMsgBody(const RspMsgBody& from);
  
  inline RspMsgBody& operator=(const RspMsgBody& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RspMsgBody& default_instance();
  
  void Swap(RspMsgBody* other);
  
  // implements Message ----------------------------------------------
  
  RspMsgBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspMsgBody& from);
  void MergeFrom(const RspMsgBody& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .weiyun.ClientFileTransQueryMsgRsp ClientFileTransQueryMsgRsp_body = 1001;
  inline bool has_clientfiletransquerymsgrsp_body() const;
  inline void clear_clientfiletransquerymsgrsp_body();
  static const int kClientFileTransQueryMsgRspBodyFieldNumber = 1001;
  inline const ::weiyun::ClientFileTransQueryMsgRsp& clientfiletransquerymsgrsp_body() const;
  inline ::weiyun::ClientFileTransQueryMsgRsp* mutable_clientfiletransquerymsgrsp_body();
  inline ::weiyun::ClientFileTransQueryMsgRsp* release_clientfiletransquerymsgrsp_body();
  
  // @@protoc_insertion_point(class_scope:weiyun.RspMsgBody)
 private:
  inline void set_has_clientfiletransquerymsgrsp_body();
  inline void clear_has_clientfiletransquerymsgrsp_body();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::weiyun::ClientFileTransQueryMsgRsp* clientfiletransquerymsgrsp_body_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msgprotobuf_2eproto();
  friend void protobuf_AssignDesc_msgprotobuf_2eproto();
  friend void protobuf_ShutdownFile_msgprotobuf_2eproto();
  
  void InitAsDefaultInstance();
  static RspMsgBody* default_instance_;
};
// -------------------------------------------------------------------

class ClientFileTransQueryMsgReq : public ::google::protobuf::Message {
 public:
  ClientFileTransQueryMsgReq();
  virtual ~ClientFileTransQueryMsgReq();
  
  ClientFileTransQueryMsgReq(const ClientFileTransQueryMsgReq& from);
  
  inline ClientFileTransQueryMsgReq& operator=(const ClientFileTransQueryMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientFileTransQueryMsgReq& default_instance();
  
  void Swap(ClientFileTransQueryMsgReq* other);
  
  // implements Message ----------------------------------------------
  
  ClientFileTransQueryMsgReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientFileTransQueryMsgReq& from);
  void MergeFrom(const ClientFileTransQueryMsgReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 file_size = 1;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 1;
  inline ::google::protobuf::int64 file_size() const;
  inline void set_file_size(::google::protobuf::int64 value);
  
  // required bytes ukey = 2;
  inline bool has_ukey() const;
  inline void clear_ukey();
  static const int kUkeyFieldNumber = 2;
  inline const ::std::string& ukey() const;
  inline void set_ukey(const ::std::string& value);
  inline void set_ukey(const char* value);
  inline void set_ukey(const void* value, size_t size);
  inline ::std::string* mutable_ukey();
  inline ::std::string* release_ukey();
  
  // required bytes file_key = 3;
  inline bool has_file_key() const;
  inline void clear_file_key();
  static const int kFileKeyFieldNumber = 3;
  inline const ::std::string& file_key() const;
  inline void set_file_key(const ::std::string& value);
  inline void set_file_key(const char* value);
  inline void set_file_key(const void* value, size_t size);
  inline ::std::string* mutable_file_key();
  inline ::std::string* release_file_key();
  
  // required string upload_domain = 4;
  inline bool has_upload_domain() const;
  inline void clear_upload_domain();
  static const int kUploadDomainFieldNumber = 4;
  inline const ::std::string& upload_domain() const;
  inline void set_upload_domain(const ::std::string& value);
  inline void set_upload_domain(const char* value);
  inline void set_upload_domain(const char* value, size_t size);
  inline ::std::string* mutable_upload_domain();
  inline ::std::string* release_upload_domain();
  
  // optional string file_name = 5;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 5;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // optional bytes file_md5 = 6;
  inline bool has_file_md5() const;
  inline void clear_file_md5();
  static const int kFileMd5FieldNumber = 6;
  inline const ::std::string& file_md5() const;
  inline void set_file_md5(const ::std::string& value);
  inline void set_file_md5(const char* value);
  inline void set_file_md5(const void* value, size_t size);
  inline ::std::string* mutable_file_md5();
  inline ::std::string* release_file_md5();
  
  // @@protoc_insertion_point(class_scope:weiyun.ClientFileTransQueryMsgReq)
 private:
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_ukey();
  inline void clear_has_ukey();
  inline void set_has_file_key();
  inline void clear_has_file_key();
  inline void set_has_upload_domain();
  inline void clear_has_upload_domain();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_md5();
  inline void clear_has_file_md5();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 file_size_;
  ::std::string* ukey_;
  ::std::string* file_key_;
  ::std::string* upload_domain_;
  ::std::string* file_name_;
  ::std::string* file_md5_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msgprotobuf_2eproto();
  friend void protobuf_AssignDesc_msgprotobuf_2eproto();
  friend void protobuf_ShutdownFile_msgprotobuf_2eproto();
  
  void InitAsDefaultInstance();
  static ClientFileTransQueryMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class ClientFileTransQueryMsgRsp : public ::google::protobuf::Message {
 public:
  ClientFileTransQueryMsgRsp();
  virtual ~ClientFileTransQueryMsgRsp();
  
  ClientFileTransQueryMsgRsp(const ClientFileTransQueryMsgRsp& from);
  
  inline ClientFileTransQueryMsgRsp& operator=(const ClientFileTransQueryMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientFileTransQueryMsgRsp& default_instance();
  
  void Swap(ClientFileTransQueryMsgRsp* other);
  
  // implements Message ----------------------------------------------
  
  ClientFileTransQueryMsgRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientFileTransQueryMsgRsp& from);
  void MergeFrom(const ClientFileTransQueryMsgRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);
  
  // optional int64 next_offset = 2;
  inline bool has_next_offset() const;
  inline void clear_next_offset();
  static const int kNextOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 next_offset() const;
  inline void set_next_offset(::google::protobuf::int64 value);
  
  // optional int32 process = 3;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 3;
  inline ::google::protobuf::int32 process() const;
  inline void set_process(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:weiyun.ClientFileTransQueryMsgRsp)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_next_offset();
  inline void clear_has_next_offset();
  inline void set_has_process();
  inline void clear_has_process();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 next_offset_;
  ::google::protobuf::int32 flag_;
  ::google::protobuf::int32 process_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msgprotobuf_2eproto();
  friend void protobuf_AssignDesc_msgprotobuf_2eproto();
  friend void protobuf_ShutdownFile_msgprotobuf_2eproto();
  
  void InitAsDefaultInstance();
  static ClientFileTransQueryMsgRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgHead

// required int64 uin = 1;
inline bool MsgHead::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHead::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHead::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHead::clear_uin() {
  uin_ = GOOGLE_LONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::int64 MsgHead::uin() const {
  return uin_;
}
inline void MsgHead::set_uin(::google::protobuf::int64 value) {
  set_has_uin();
  uin_ = value;
}

// required uint32 seq = 2;
inline bool MsgHead::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHead::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHead::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHead::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 MsgHead::seq() const {
  return seq_;
}
inline void MsgHead::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
}

// optional .weiyun.MsgHead.Type type = 3;
inline bool MsgHead::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgHead::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgHead::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgHead::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::weiyun::MsgHead_Type MsgHead::type() const {
  return static_cast< ::weiyun::MsgHead_Type >(type_);
}
inline void MsgHead::set_type(::weiyun::MsgHead_Type value) {
  GOOGLE_DCHECK(::weiyun::MsgHead_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 cmd = 4;
inline bool MsgHead::has_cmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgHead::set_has_cmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgHead::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgHead::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 MsgHead::cmd() const {
  return cmd_;
}
inline void MsgHead::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 retcode = 101;
inline bool MsgHead::has_retcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgHead::set_has_retcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgHead::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgHead::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 MsgHead::retcode() const {
  return retcode_;
}
inline void MsgHead::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional string retmsg = 102;
inline bool MsgHead::has_retmsg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgHead::set_has_retmsg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgHead::clear_has_retmsg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgHead::clear_retmsg() {
  if (retmsg_ != &::google::protobuf::internal::kEmptyString) {
    retmsg_->clear();
  }
  clear_has_retmsg();
}
inline const ::std::string& MsgHead::retmsg() const {
  return *retmsg_;
}
inline void MsgHead::set_retmsg(const ::std::string& value) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(value);
}
inline void MsgHead::set_retmsg(const char* value) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(value);
}
inline void MsgHead::set_retmsg(const char* value, size_t size) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgHead::mutable_retmsg() {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  return retmsg_;
}
inline ::std::string* MsgHead::release_retmsg() {
  clear_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = retmsg_;
    retmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MsgBody

// optional .weiyun.ReqMsgBody ReqMsg_body = 1;
inline bool MsgBody::has_reqmsg_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBody::set_has_reqmsg_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBody::clear_has_reqmsg_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBody::clear_reqmsg_body() {
  if (reqmsg_body_ != NULL) reqmsg_body_->::weiyun::ReqMsgBody::Clear();
  clear_has_reqmsg_body();
}
inline const ::weiyun::ReqMsgBody& MsgBody::reqmsg_body() const {
  return reqmsg_body_ != NULL ? *reqmsg_body_ : *default_instance_->reqmsg_body_;
}
inline ::weiyun::ReqMsgBody* MsgBody::mutable_reqmsg_body() {
  set_has_reqmsg_body();
  if (reqmsg_body_ == NULL) reqmsg_body_ = new ::weiyun::ReqMsgBody;
  return reqmsg_body_;
}
inline ::weiyun::ReqMsgBody* MsgBody::release_reqmsg_body() {
  clear_has_reqmsg_body();
  ::weiyun::ReqMsgBody* temp = reqmsg_body_;
  reqmsg_body_ = NULL;
  return temp;
}

// optional .weiyun.RspMsgBody RspMsg_body = 2;
inline bool MsgBody::has_rspmsg_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBody::set_has_rspmsg_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBody::clear_has_rspmsg_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBody::clear_rspmsg_body() {
  if (rspmsg_body_ != NULL) rspmsg_body_->::weiyun::RspMsgBody::Clear();
  clear_has_rspmsg_body();
}
inline const ::weiyun::RspMsgBody& MsgBody::rspmsg_body() const {
  return rspmsg_body_ != NULL ? *rspmsg_body_ : *default_instance_->rspmsg_body_;
}
inline ::weiyun::RspMsgBody* MsgBody::mutable_rspmsg_body() {
  set_has_rspmsg_body();
  if (rspmsg_body_ == NULL) rspmsg_body_ = new ::weiyun::RspMsgBody;
  return rspmsg_body_;
}
inline ::weiyun::RspMsgBody* MsgBody::release_rspmsg_body() {
  clear_has_rspmsg_body();
  ::weiyun::RspMsgBody* temp = rspmsg_body_;
  rspmsg_body_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ReqMsgBody

// optional .weiyun.ClientFileTransQueryMsgReq ClientFileTransQueryMsgReq_body = 1001;
inline bool ReqMsgBody::has_clientfiletransquerymsgreq_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqMsgBody::set_has_clientfiletransquerymsgreq_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqMsgBody::clear_has_clientfiletransquerymsgreq_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqMsgBody::clear_clientfiletransquerymsgreq_body() {
  if (clientfiletransquerymsgreq_body_ != NULL) clientfiletransquerymsgreq_body_->::weiyun::ClientFileTransQueryMsgReq::Clear();
  clear_has_clientfiletransquerymsgreq_body();
}
inline const ::weiyun::ClientFileTransQueryMsgReq& ReqMsgBody::clientfiletransquerymsgreq_body() const {
  return clientfiletransquerymsgreq_body_ != NULL ? *clientfiletransquerymsgreq_body_ : *default_instance_->clientfiletransquerymsgreq_body_;
}
inline ::weiyun::ClientFileTransQueryMsgReq* ReqMsgBody::mutable_clientfiletransquerymsgreq_body() {
  set_has_clientfiletransquerymsgreq_body();
  if (clientfiletransquerymsgreq_body_ == NULL) clientfiletransquerymsgreq_body_ = new ::weiyun::ClientFileTransQueryMsgReq;
  return clientfiletransquerymsgreq_body_;
}
inline ::weiyun::ClientFileTransQueryMsgReq* ReqMsgBody::release_clientfiletransquerymsgreq_body() {
  clear_has_clientfiletransquerymsgreq_body();
  ::weiyun::ClientFileTransQueryMsgReq* temp = clientfiletransquerymsgreq_body_;
  clientfiletransquerymsgreq_body_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RspMsgBody

// optional .weiyun.ClientFileTransQueryMsgRsp ClientFileTransQueryMsgRsp_body = 1001;
inline bool RspMsgBody::has_clientfiletransquerymsgrsp_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspMsgBody::set_has_clientfiletransquerymsgrsp_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspMsgBody::clear_has_clientfiletransquerymsgrsp_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspMsgBody::clear_clientfiletransquerymsgrsp_body() {
  if (clientfiletransquerymsgrsp_body_ != NULL) clientfiletransquerymsgrsp_body_->::weiyun::ClientFileTransQueryMsgRsp::Clear();
  clear_has_clientfiletransquerymsgrsp_body();
}
inline const ::weiyun::ClientFileTransQueryMsgRsp& RspMsgBody::clientfiletransquerymsgrsp_body() const {
  return clientfiletransquerymsgrsp_body_ != NULL ? *clientfiletransquerymsgrsp_body_ : *default_instance_->clientfiletransquerymsgrsp_body_;
}
inline ::weiyun::ClientFileTransQueryMsgRsp* RspMsgBody::mutable_clientfiletransquerymsgrsp_body() {
  set_has_clientfiletransquerymsgrsp_body();
  if (clientfiletransquerymsgrsp_body_ == NULL) clientfiletransquerymsgrsp_body_ = new ::weiyun::ClientFileTransQueryMsgRsp;
  return clientfiletransquerymsgrsp_body_;
}
inline ::weiyun::ClientFileTransQueryMsgRsp* RspMsgBody::release_clientfiletransquerymsgrsp_body() {
  clear_has_clientfiletransquerymsgrsp_body();
  ::weiyun::ClientFileTransQueryMsgRsp* temp = clientfiletransquerymsgrsp_body_;
  clientfiletransquerymsgrsp_body_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ClientFileTransQueryMsgReq

// required int64 file_size = 1;
inline bool ClientFileTransQueryMsgReq::has_file_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientFileTransQueryMsgReq::set_has_file_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientFileTransQueryMsgReq::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientFileTransQueryMsgReq::clear_file_size() {
  file_size_ = GOOGLE_LONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::int64 ClientFileTransQueryMsgReq::file_size() const {
  return file_size_;
}
inline void ClientFileTransQueryMsgReq::set_file_size(::google::protobuf::int64 value) {
  set_has_file_size();
  file_size_ = value;
}

// required bytes ukey = 2;
inline bool ClientFileTransQueryMsgReq::has_ukey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientFileTransQueryMsgReq::set_has_ukey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientFileTransQueryMsgReq::clear_has_ukey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientFileTransQueryMsgReq::clear_ukey() {
  if (ukey_ != &::google::protobuf::internal::kEmptyString) {
    ukey_->clear();
  }
  clear_has_ukey();
}
inline const ::std::string& ClientFileTransQueryMsgReq::ukey() const {
  return *ukey_;
}
inline void ClientFileTransQueryMsgReq::set_ukey(const ::std::string& value) {
  set_has_ukey();
  if (ukey_ == &::google::protobuf::internal::kEmptyString) {
    ukey_ = new ::std::string;
  }
  ukey_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_ukey(const char* value) {
  set_has_ukey();
  if (ukey_ == &::google::protobuf::internal::kEmptyString) {
    ukey_ = new ::std::string;
  }
  ukey_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_ukey(const void* value, size_t size) {
  set_has_ukey();
  if (ukey_ == &::google::protobuf::internal::kEmptyString) {
    ukey_ = new ::std::string;
  }
  ukey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientFileTransQueryMsgReq::mutable_ukey() {
  set_has_ukey();
  if (ukey_ == &::google::protobuf::internal::kEmptyString) {
    ukey_ = new ::std::string;
  }
  return ukey_;
}
inline ::std::string* ClientFileTransQueryMsgReq::release_ukey() {
  clear_has_ukey();
  if (ukey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ukey_;
    ukey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes file_key = 3;
inline bool ClientFileTransQueryMsgReq::has_file_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientFileTransQueryMsgReq::set_has_file_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientFileTransQueryMsgReq::clear_has_file_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientFileTransQueryMsgReq::clear_file_key() {
  if (file_key_ != &::google::protobuf::internal::kEmptyString) {
    file_key_->clear();
  }
  clear_has_file_key();
}
inline const ::std::string& ClientFileTransQueryMsgReq::file_key() const {
  return *file_key_;
}
inline void ClientFileTransQueryMsgReq::set_file_key(const ::std::string& value) {
  set_has_file_key();
  if (file_key_ == &::google::protobuf::internal::kEmptyString) {
    file_key_ = new ::std::string;
  }
  file_key_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_file_key(const char* value) {
  set_has_file_key();
  if (file_key_ == &::google::protobuf::internal::kEmptyString) {
    file_key_ = new ::std::string;
  }
  file_key_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_file_key(const void* value, size_t size) {
  set_has_file_key();
  if (file_key_ == &::google::protobuf::internal::kEmptyString) {
    file_key_ = new ::std::string;
  }
  file_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientFileTransQueryMsgReq::mutable_file_key() {
  set_has_file_key();
  if (file_key_ == &::google::protobuf::internal::kEmptyString) {
    file_key_ = new ::std::string;
  }
  return file_key_;
}
inline ::std::string* ClientFileTransQueryMsgReq::release_file_key() {
  clear_has_file_key();
  if (file_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_key_;
    file_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string upload_domain = 4;
inline bool ClientFileTransQueryMsgReq::has_upload_domain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientFileTransQueryMsgReq::set_has_upload_domain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientFileTransQueryMsgReq::clear_has_upload_domain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientFileTransQueryMsgReq::clear_upload_domain() {
  if (upload_domain_ != &::google::protobuf::internal::kEmptyString) {
    upload_domain_->clear();
  }
  clear_has_upload_domain();
}
inline const ::std::string& ClientFileTransQueryMsgReq::upload_domain() const {
  return *upload_domain_;
}
inline void ClientFileTransQueryMsgReq::set_upload_domain(const ::std::string& value) {
  set_has_upload_domain();
  if (upload_domain_ == &::google::protobuf::internal::kEmptyString) {
    upload_domain_ = new ::std::string;
  }
  upload_domain_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_upload_domain(const char* value) {
  set_has_upload_domain();
  if (upload_domain_ == &::google::protobuf::internal::kEmptyString) {
    upload_domain_ = new ::std::string;
  }
  upload_domain_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_upload_domain(const char* value, size_t size) {
  set_has_upload_domain();
  if (upload_domain_ == &::google::protobuf::internal::kEmptyString) {
    upload_domain_ = new ::std::string;
  }
  upload_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientFileTransQueryMsgReq::mutable_upload_domain() {
  set_has_upload_domain();
  if (upload_domain_ == &::google::protobuf::internal::kEmptyString) {
    upload_domain_ = new ::std::string;
  }
  return upload_domain_;
}
inline ::std::string* ClientFileTransQueryMsgReq::release_upload_domain() {
  clear_has_upload_domain();
  if (upload_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = upload_domain_;
    upload_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string file_name = 5;
inline bool ClientFileTransQueryMsgReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientFileTransQueryMsgReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientFileTransQueryMsgReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientFileTransQueryMsgReq::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& ClientFileTransQueryMsgReq::file_name() const {
  return *file_name_;
}
inline void ClientFileTransQueryMsgReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientFileTransQueryMsgReq::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* ClientFileTransQueryMsgReq::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes file_md5 = 6;
inline bool ClientFileTransQueryMsgReq::has_file_md5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientFileTransQueryMsgReq::set_has_file_md5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientFileTransQueryMsgReq::clear_has_file_md5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientFileTransQueryMsgReq::clear_file_md5() {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    file_md5_->clear();
  }
  clear_has_file_md5();
}
inline const ::std::string& ClientFileTransQueryMsgReq::file_md5() const {
  return *file_md5_;
}
inline void ClientFileTransQueryMsgReq::set_file_md5(const ::std::string& value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_file_md5(const char* value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void ClientFileTransQueryMsgReq::set_file_md5(const void* value, size_t size) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientFileTransQueryMsgReq::mutable_file_md5() {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  return file_md5_;
}
inline ::std::string* ClientFileTransQueryMsgReq::release_file_md5() {
  clear_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_md5_;
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientFileTransQueryMsgRsp

// optional int32 flag = 1;
inline bool ClientFileTransQueryMsgRsp::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientFileTransQueryMsgRsp::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientFileTransQueryMsgRsp::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientFileTransQueryMsgRsp::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 ClientFileTransQueryMsgRsp::flag() const {
  return flag_;
}
inline void ClientFileTransQueryMsgRsp::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
}

// optional int64 next_offset = 2;
inline bool ClientFileTransQueryMsgRsp::has_next_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientFileTransQueryMsgRsp::set_has_next_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientFileTransQueryMsgRsp::clear_has_next_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientFileTransQueryMsgRsp::clear_next_offset() {
  next_offset_ = GOOGLE_LONGLONG(0);
  clear_has_next_offset();
}
inline ::google::protobuf::int64 ClientFileTransQueryMsgRsp::next_offset() const {
  return next_offset_;
}
inline void ClientFileTransQueryMsgRsp::set_next_offset(::google::protobuf::int64 value) {
  set_has_next_offset();
  next_offset_ = value;
}

// optional int32 process = 3;
inline bool ClientFileTransQueryMsgRsp::has_process() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientFileTransQueryMsgRsp::set_has_process() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientFileTransQueryMsgRsp::clear_has_process() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientFileTransQueryMsgRsp::clear_process() {
  process_ = 0;
  clear_has_process();
}
inline ::google::protobuf::int32 ClientFileTransQueryMsgRsp::process() const {
  return process_;
}
inline void ClientFileTransQueryMsgRsp::set_process(::google::protobuf::int32 value) {
  set_has_process();
  process_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace weiyun

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::weiyun::MsgHead_Type>() {
  return ::weiyun::MsgHead_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< weiyun::Cmd>() {
  return weiyun::Cmd_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msgprotobuf_2eproto__INCLUDED
