
# History
1962 [One-Level Storage System](http://www.dcs.gla.ac.uk/~wpc/grcs/kilburn.pdf)
[The Manchester Mark I and Atlas: A Historical Perspective](https://dl.acm.org/citation.cfm?id=359331)

# Purposes
The following is cited from 'before virtual memory' by Peter J. Denning at George Mason University
From their beginnings in the 1940s, electronic computers had two-level storage
systems. In the 1950s, main memory was magnetic cores (today it is RAMs); the
secondary memory was magnetic drums (today it is disks). The processor (CPU)
could address only the main memory. A major part of a programmer’s job was
to devise a good way to divide a program into blocks and to schedule their
moves between the levels. The blocks were called “segments” or “pages” and
the movement operations “overlays” or “swaps”. The designers of the first
operating systems in the 1950s dreamt of relieving the programming burden by
automating all this storage management.

# Formal causes
v3a Chapter 4
Also come from 'before virtual memory'.
At the heart of their idea was a radical innovation --- a distinction between “address” and “memory location”.
Firo: address => virtual address; "memory location" => physical address. Marvellous!
It led them to three inventions. 
(1) They built hardware that automatically translated each address generated by the processor to its current memory location.
Firo: this hardware is MMU including TLB.
(2) They devised demand paging, an interrupt mechanism triggered by the address translator that moved a missing page of data into the main memory.
(3) They built a replacement algorithm, a procedure to detect and move the least useful pages back to secondary memory.
Firo: PFRA
## address translator MMU

## Page tables
v3a: P121 
5 (A) Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry (see Section 4.8)
6 (D) Dirty; indicates whether software has written to the 4-KByte page referenced by this entry (see Section 4.8)
Check _PAGE_BIT_ACCESSED

## Page faults

# Material
## Walk and change page tables
ptdump_walk_pgd_level_core
and change page attr
__change_page_attr

For vmalloc(), chechk here vmap_page_range_noflush()
For kmap(), check kmap_init()
[How to emulate the process of translate va to pa?](http://edsionte.com/techblog/archives/1966)
## Onset
setup_arch->
	early_trap_pf_init //  X86_TRAP_PF, page_fault) => do_page_fault
	init_mem_mapping //set page table and cr3.

## x86_64
PAE is 3-level page tables: pgd, pmd, pte.
So early_level4_pgt(level4, level3, level2) in startup_64() with 
ENTRY(secondary_startup_64)
  /* Enable PAE mode and PGE */
  movl  $(X86_CR4_PAE | X86_CR4_PGE), %ecx
  movq  %rcx, %cr4
  /* Setup early boot stage 4 level pagetables. */
  addq  phys_base(%rip), %rax
  movq  %rax, %cr3
X86_CR0_PG: enable paging.
x86_64_start_kernel

# PTE and PDE and page flags
v3a chapter 4.5 4-level paging, p132, Figure 4-11. Formats of CR3 and Paging-Structure Entries with 4-Level Paging
| G | PAT | D | A | PCD | PWT | U/S | R/W | Present
## PTE pte_none
x86/mm: Ignore A/D bits in pte/pmd/pud_none() -  97e3c602ccbdd7db54e92fe05675c664c052a466
## PTE Encode and de-code a swap entry

|     ...            | 11| 10|  9|8|7|6|5| 4| 3|2| 1|0| <- bit number
|     ...            |SW3|SW2|SW1|G|L|D|A|CD|WT|U| W|P| <- bit names
| OFFSET (14->63) | TYPE (9-13)  |0|0|X|X| X| X|X|SD|0| <- swp entry
Check SWP_TYPE_FIRST_BIT
Swap work on only userspace pages.
## _PAGE_SWP_SOFT_DIRTY
Documentation/vm/soft-dirty.txt

# ETC
## _refcount
after __alloc_pages_nodemask _refcount=0, 
post_alloc_hook: init should be 0. 
but set_page_refcounted -> set_page_count(page, 1);
and Check put_page
## _mapcount
from -1: page_mapcount_reset
All processes's page table(task_strcut pgd) was derived form init_mm's swapper_pg_dir which inited in native_pagetable_init(). #FIXME.
