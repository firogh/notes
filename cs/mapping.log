# Kernel memory mapping

## 0xffff880000000000 ~ "0xffff880000000000 +max_fpn << PAGE_SHIFT" or variable high_memory : direct map memory
(0x1000000000000 -0x880000000000) /1024.0 /1024.0/1024.0/1024.0
120.0 TB
setup_arch->init_mem_mapping ... -> init_memory_mapping -> kernel_physical_mapping_init

## 0xffffffff80000000 ~ 2G
call early_make_pgtable??
x86_64_start_kernel ->
init_level4_pgt[511] = early_level4_pgt[511];

## Hotplug
...->arch_add_memory->init_memory_mapping

# Vmemmap
## Normal boot
setup_arch
x86_init.paging.pagetable_init = native_pagetable_init = paging_init->sparse_init ...-> vmemmap_populate
## Hotplug
add_memory
|-add_memory_resource
 |-add_memory_resource
  |-arch_add_memory
   |-__add_pages
    |-__add_section
     |-sparse_add_one_section
      |-kmalloc_section_memmap
       |-sparse_mem_map_populate
        |-vmemmap_populate

# Vmalloc
map_vm_area 页表映射
the page in ZONE_NORMAL will not use directly mapping pfn address! It use VMALLOC address!
## Vmalloc coherence with vfree() after vmalloc_sync_one
在进程的内核页目录中补上的是只是页目录项，而页表对所有进程来说是共用的，不管vfree()多大的内存块，在vmalloc()时新分配的页表不会被释放，当重新vmalloc()时，仍旧使用原来的页表。 page_fault使得进程的内核页目录项与swapper_pg_dir保持同步，swapper_pg_dir的内核页目录项一旦建立就不再被改变，需要改变的只是共享的页表而已。
deatils in vmalloc_sync_one() and vunmap_pte_range()
只释放pte

# x86
## Persistent Kernel Mappings
kmap(struct page *)
How kmap works? 
Check kmap_init(), later!

## Temporay Mappings(Fixmaps)
kmap_atomic()
