# Memory variables
extern unsigned long max_low_pfn;
extern unsigned long min_low_pfn;
extern unsigned long max_pfn;
high_memory
Committed_AS and __vm_enough_memory

# Pages
[Some are in the "page cache" used to store the contents of files.](https://lwn.net/Articles/446317/) 
Some are "anonymous pages" holding data used by applications. 
Some are used as "slabs" and divided into pieces to answer kmalloc() requests. 
Others are simply part of a multi-page allocation or maybe are on a free list waiting to be used. 
Each of these different use cases could be seen as a subtype of the general class of "page".  -- Neil Brown.

## In page fault
Ondemanding page
COW - do_wp_page
Major fault, or minor fault.
Private, shared, anonymous, file pages
## Page frame reclaimation
page_is_file_cache
Check page_check_dirty_writeback() for anonymous pages's definition.
        /*
         * Anonymous pages are not handled by flushers and must be written
         * from reclaim context. Do not stall reclaim based on them
         */
        if (!page_is_file_cache(page) ||
            (PageAnon(page) && !PageSwapBacked(page))) {
                *dirty = false;
                *writeback = false;
                return;
        }

# VM stat
/proc/meminfo
meminfo_proc_show
/proc/zoneinfo
## Buffer cache of command 'free'
"Buffers" represent how much portion of RAM is dedicated to cache disk blocks
1. Open block device directly open("/dev/sdb"...) -> blkdev_open
2. Read metadata,including indirect blocks, bitmap,  sb_getblk->... -> grow_dev_page

## Threshhold
Check calculate_normal_threshold

# ETC
[page owner](https://www.kernel.org/doc/html/v4.18/vm/page_owner.html)

# Slab
/proc/slabinfo

# Memory available
[provide estimated available memory in /proc/meminfo](https://lore.kernel.org/patchwork/patch/417981/)
equation for calculating all available memory 
freeram + LRU_ACTIVE_FILE + LRU_INACTIVE_FILE + NR_SLAB_RECLAIMABLE 

# HW availbae memory 
>>> 6439184 + 36648 + 17089808 + 2511088 - 12524
26064204
>>> 4169316 + 31728 + 14645916 + 2200224 - 12520
21034664
>>> 5902536 + 49160 + 12616744 + 1400240 - 12524
19956156

# NR_WRITEBACK
FIXME: pages accounted for in NR_WRITEBACK are not on the LRU lists  any more, right?
Right. Check right.

# Zone based memory states
commit 2244b95a7bcf8d24196f8a3a44187ba5dfff754c
Author: Christoph Lameter <clameter@sgi.com>
Date:   Fri Jun 30 01:55:33 2006 -0700
    [PATCH] zoned vm counters: basic ZVC (zoned vm counter) implementation

# Node based memory states
commit 599d0c954f91d0689c9bb421b5bc04ea02437a41
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Thu Jul 28 15:45:31 2016 -0700
    mm, vmscan: move LRU lists to node
commit 11fb998986a72aa7e997d96d63d52582a01228c5
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Thu Jul 28 15:46:20 2016 -0700

    mm: move most file-based accounting to the node
v4.7-5957-gbca6759258db
commit bca6759258dbef378bcf5b872177bcd2259ceb68
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Thu Jul 28 15:47:05 2016 -0700
    mm, vmstat: remove zone and node double accounting by approximating retries

## Zone based memory states partially come back
commit 71c799f4982d340fff86e751898841322f07f235
Author: Minchan Kim <minchan@kernel.org>
Date:   Thu Jul 28 15:47:26 2016 -0700

    mm: add per-zone lru list stat
Check update_lru_size

# LQO
ramfs pages first go to (in)active lists, moves to unevictable later, so it's not really true already. ;)
why mapping_set_unevictable(inode->i_mapping);  in ramfs_get_inode. Check https://serverfault.com/a/590133/143494

# Facts
LRU_IN/ACTIVE_ANON in cached: error = shmem_add_to_page_cache(page, mapping, index, gfp, NULL); lru_cache_add_anon(page);
NR_FILE_PAGES includes NR_SHMEM and buffers during add to page cache.
Cached in meminfo_proc_show() NR_FILE_PAGES includes NR_SHMEM in replace_page_cache_page()
Shmem: NR_SHMEM
Mapped: NR_FILE_MAPPED /* pagecache pages mapped into pagetables. do_xx_fault mm/rmap.c:1236:		__inc_zone_page_state(page, NR_FILE_MAPPED);
AnonPages: NR_ANON_PAGES Mapped anonymous pages do_xx_fault
#ifdef CONFIG_TRANSPARENT_HUGEPAGE
                K(global_page_state(NR_ANON_PAGES)
                  + global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *
                  HPAGE_PMD_NR)

## RAMFS shmem unevictable
fs/ramfs/inode.c <<ramfs_get_inode>>
             mapping_set_unevictable(inode->i_mapping);
mm/shmem.c <<shmem_lock>>
             mapping_set_unevictable(file->f_mapping);
SHM_LOCK (Linux-specific)
                 Prevent  swapping  of the shared memory segment. 
=======
# Memory leak
