Experience

I have solved many system issues in SUSE. Most of them can be categorized into two groups: crash issues and performance issues.

# For crash issues, I haved analyzed more than 100 kernel dumps with crash-utility. I can recall some challening issues I solved:
1) Kernel crashed due to buggy stack pointer(rsp). The most difficult part for this issue is that if this issue happens, then the call traces on stack will be overwritten by page fault handler. It means that you have no idea on what really has happened. 

I came with an idea to solve this issue which is using X86 IST stack to prevent page fault handler from overwriting the task's stack.
Here is the patch: https://github.com/firogh/notes/blob/master/box/0001-x86_64-page-fault-Introduce-pf_ist.patch

The root cause for this issue is that a patch for ebpf miscalculated the x86 rsp.

2) Another kernel crash issue. Kernel crashed in network stack due to using a wrong API to release refernce counter. I figured out the root cause by analyzing dump and going through the source of kernel network stack. The following is the stack traces for this issue.
PID: 58411  TASK: ffff8d43eb61d180  CPU: 0   COMMAND: "python"
 #0 [ffff8cd51f6037f0] machine_kexec at ffffffffb0066912
 #1 [ffff8cd51f603840] __crash_kexec at ffffffffb012bafa
 #2 [ffff8cd51f603900] panic at ffffffffb01ca90e
 #3 [ffff8cd51f603978] oops_end at ffffffffb003240f
 #4 [ffff8cd51f6039e0] do_error_trap at ffffffffb00305a4
 #5 [ffff8cd51f603a90] invalid_op at ffffffffb0800fcb
    [exception RIP: ____cache_alloc+529]
    RIP: ffffffffb0264854  RSP: ffff8cd51f603b40  RFLAGS: 00010082
    RAX: ffffe5b3326c4200  RBX: ffffcf2ebfe07a60  RCX: ffff8cd51e63e408
    RDX: 0000000000000000  RSI: ffffe5b3326c4200  RDI: 000000000000000d
    RBP: ffff8cd51e63e408   R8: 0000000000000000   R9: 0000000000000000
    R10: 0000000000000000  R11: 0000000000000001  R12: ffff8cd51e63e400
    R13: ffffcf2ebfe07a60  R14: ffff8cd51e5c1500  R15: 0000000000000008
    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018
 #6 [ffff8cd51f603b80] kmem_cache_alloc at ffffffffb023a66d
 #7 [ffff8cd51f603bb8] inet_reqsk_alloc at ffffffffb065c410
 #8 [ffff8cd51f603bd8] tcp_conn_request at ffffffffb065dcf3
 #9 [ffff8cd51f603ce8] tcp_rcv_state_process at ffffffffb0663be7
#10 [ffff8cd51f603d68] tcp_v4_do_rcv at ffffffffb066ec10
#11 [ffff8cd51f603d88] tcp_v4_rcv at ffffffffb067009f
#12 [ffff8cd51f603e18] ip_local_deliver_finish at ffffffffb06496b6
#13 [ffff8cd51f603e38] ip_local_deliver at ffffffffb0649a2b
#14 [ffff8cd51f603e80] ip_rcv at ffffffffb0649ad2
#15 [ffff8cd51f603ed0] __netif_receive_skb_one_core at ffffffffb05f7efa
#16 [ffff8cd51f603ef0] process_backlog at ffffffffb05f907f
#17 [ffff8cd51f603f28] net_rx_action at ffffffffb05f8ea1
#18 [ffff8cd51f603f98] __softirqentry_text_start at ffffffffb0a000ce
#19 [ffff8cd51f603ff0] do_softirq_own_stack at ffffffffb080129a

Here is the analysis made by me for this issue.
https://github.com/firogh/notes/blob/master/box/network_refcount_issue.log

To fix this kind of issue, there aren't many tools like kasan which can be used in customer's product environment; reading the source codes sometimes is the only option. To be frank, a few years a ago, I really liked reading kernel source codes. There are a lot of fun in it. Here are my notes on kernel: https://github.com/firogh/notes/tree/master/cs. Sorry, they are likely not readable to others.

3) Sometimes, we also received dump generated due to soft or hard lockup.
I worte a small script based on drgn to locate the holder of an spinlock causing lockup:
https://github.com/firogh/notes/blob/master/box/qspinlock.py
In fact, sometimes it's required to analyzed call traces/stack frames in dump to locate the real holder of spinlock because the holder might acquire the lock before contention appears. I this kind of case, using crash-utility is 'search' command would be very helpful.

# For performance issue, I like using tracing tools, e.g. perf, ftrace/trace-cmd, ebpf to solve problems.
Here is a bcc/ebpf script I used to solve a memory leak problem occuring at the page allocator level:
https://github.com/firogh/notes/blob/master/box/xpageleak.py

# Open sources
I didn't work in upsteam community, so there are only a few kernel upsteam fixes:
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?qt=grep&q=firo.yang%40suse.com
and an improvment on crash utility
https://github.com/crash-utility/crash/commit/f091b5e76d2d6e81b12cd40df7b5863c9e2efed1

Career development

I want to be a kernel memory maintainer in future. So C would be my preferred programming language. 

I started using Linux distro 10 years ago. And since that there is only one operating system on my laptop which is Linux. So basically, I use Linux and vim and gnome everyday. It's been a important part of my life.

As for proudest moments, it would be letters of appreciation from our customer. And sometimes I can solve issues as twice as others. 
For downfalls, one of our customer is moving to VMware from our Xen product due to a difficut memory corrution issue whose root cause is still unkown to me.

Education

I have a computer science bachelor degree. My strongest subject would be operating system... I am good at analyzing problems. Ten-year study on philosopy. 

Context

Canonical is an opensource compay. I also make my living on opensource. So we should fit each other well. I was touched by the idea of post-scarcity when I heard it 10 years ago. It's unreal for physical world, but it would likely be realized in software world in future.

Honestly, I am looking for an opportunity to help me move out from China to other country like Japan.


