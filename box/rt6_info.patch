diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index bab3531e3696..b87d246507b1 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -3169,6 +3169,7 @@ static int ip6_route_multipath_add(struct fib6_config *cfg,
 
        err_nh = NULL;
        list_for_each_entry(nh, &rt6_nh_list, next) {
+               rt6_hold(nh->rt6_info);
                err = __ip6_ins_rt(nh->rt6_info, info, &nh->mxc, extack);
 
                if (err) {
@@ -3178,12 +3179,17 @@ static int ip6_route_multipath_add(struct fib6_config *cfg,
                        goto add_errout;
                }
                /* save reference to last route successfully inserted */
+               if (rt_last)
+                       rt6_release(rt_last);
                rt_last = nh->rt6_info;
 
                /* save reference to first route for notification */
-               if (!rt_notif)
+               if (!rt_notif) {
+                       rt6_hold(nh->rt6_info);
                        rt_notif = nh->rt6_info;
+               }
 
+               nh->rt6_info = NULL;
                /* Because each route is added like a single route we remove
                 * these flags after the first nexthop: if there is a collision,
                 * we have already failed to add the first nexthop:
@@ -3217,8 +3223,14 @@ static int ip6_route_multipath_add(struct fib6_config *cfg,
        }
 
 cleanup:
+       if (rt_notif) {
+               rt6_release(rt_notif);
+               rt6_release(rt_last);
+       }
+
        list_for_each_entry_safe(nh, nh_safe, &rt6_nh_list, next) {
-               dst_release_immediate(&nh->rt6_info->dst);
+               if (nh->rt6_info)
+                       dst_release_immediate(&nh->rt6_info->dst);
                kfree(nh->mxc.mx);
                list_del(&nh->next);
                kfree(nh);

