(gdb) bt
#0  sock_state_print (s=s@entry=0x7fffffffd6a0) at /usr/src/debug/iproute-6.12.0-3.fc42.x86_64/misc/ss.c:1422
#1  0x00005555555623d6 in inet_stats_print (s=0x7fffffffd6a0, v6only=false) at /usr/src/debug/iproute-6.12.0-3.fc42.x86_64/misc/ss.c:2470
#2  inet_show_sock (nlh=nlh@entry=0x55555558081c, s=s@entry=0x7fffffffd6a0) at /usr/src/debug/iproute-6.12.0-3.fc42.x86_64/misc/ss.c:3767
#3  0x0000555555562d0f in show_one_inet_sock (h=0x55555558081c, arg=0x7fffffffdaa0) at /usr/src/debug/iproute-6.12.0-3.fc42.x86_64/misc/ss.c:4091
#4  0x0000555555567ab6 in rtnl_dump_filter_l.constprop.0 (rth=rth@entry=0x7fffffffdac0, arg=arg@entry=0x7fffffffdc00) at ../lib/libnetlink.c:926
#5  0x000055555555b3a6 in rtnl_dump_filter_nc (nc_flags=0, rth=0x7fffffffdac0, filter=0x555555562b60 <show_one_inet_sock>, arg1=0x7fffffffdaa0)
    at ../lib/libnetlink.c:969
#6  inet_show_netlink (dump_fp=dump_fp@entry=0x0, protocol=protocol@entry=6, f=0x555555577fa0 <current_filter>)
    at /usr/src/debug/iproute-6.12.0-3.fc42.x86_64/misc/ss.c:4133
#7  0x00005555555576a4 in tcp_show (f=0x555555577fa0 <current_filter>) at /usr/src/debug/iproute-6.12.0-3.fc42.x86_64/misc/ss.c:4239
#8  main (argc=<optimized out>, argv=<optimized out>) at /usr/src/debug/iproute-6.12.0-3.fc42.x86_64/misc/ss.c:6277

static void tcp_diag_get_info(struct sock *sk, struct inet_diag_msg *r, 
                              void *_info)
{
        struct tcp_info *info = _info;

        if (inet_sk_state_load(sk) == TCP_LISTEN) {
                r->idiag_rqueue = READ_ONCE(sk->sk_ack_backlog);
                r->idiag_wqueue = READ_ONCE(sk->sk_max_ack_backlog);
        } else if (sk->sk_type == SOCK_STREAM) {
                const struct tcp_sock *tp = tcp_sk(sk);

                r->idiag_rqueue = max_t(int, READ_ONCE(tp->rcv_nxt) -
                                             READ_ONCE(tp->copied_seq), 0); 
                r->idiag_wqueue = READ_ONCE(tp->write_seq) - tp->snd_una;
        }
        if (info)
                tcp_get_info(sk, info);
}


net/ipv4/tcp_ipv4.c
                rx_queue = max_t(int, READ_ONCE(tp->rcv_nxt) -
                                      READ_ONCE(tp->copied_seq), 0);
        seq_printf(f, "%4d: %08X:%04X %08X:%04X %02X %08X:%08X %02X:%08lX "
                        "%08X %5u %8d %lu %d %pK %lu %lu %u %u %d",
                i, src, srcp, dest, destp, state,
                READ_ONCE(tp->write_seq) - tp->snd_una,
                rx_queue,
                timer_active,
                jiffies_delta_to_clock_t(timer_expires - jiffies),
                icsk->icsk_retransmits,

Accept queue of syn
        if (sk_acceptq_is_full(sk)) {
                NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
                return 0;

sysctl_max_syn_backlog
file: /proc/sys/net/ipv4/tcp_max_syn_backlog
variable: net.ipv4.tcp_max_syn_backlog
https://sysctl-explorer.net/net/ipv4/tcp_max_syn_backlog/
        
skb sock sk_receive_queue
net/ipv4/tcp_input.c:5198:		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);
net/ipv4/tcp_input.c:5286:				NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);
net/ipv4/proc.c:294:	SNMP_MIB_ITEM("TCPRcvQDrop", LINUX_MIB_TCPRCVQDROP),

skb backlog queue
int tcp_v4_rcv(struct sk_buff *skb)
{
[...]
        if (!sock_owned_by_user(sk)) { #'lock issue'
                ret = tcp_v4_do_rcv(sk, skb);
        } else {
                if (tcp_add_backlog(sk, skb, &drop_reason))
                        goto discard_and_relse;
        } 
net/ipv4/proc.c:246:	SNMP_MIB_ITEM("TCPBacklogDrop", LINUX_MIB_TCPBACKLOGDROP),
        if (unlikely(sk_add_backlog(sk, skb, limit))) {
                bh_unlock_sock(sk);
                *reason = SKB_DROP_REASON_SOCKET_BACKLOG;
                __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPBACKLOGDROP);
                return true;
awk '{for(i=1;i<=NF;i++)title[i] = $i; getline; print title[1]; for(i=2;i<=NF;i++)printf " %s: %s\n", title[i], $i }' /proc/net/netstat

