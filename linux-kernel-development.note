* Topic list

  | struct list_head                   | linux/list.h |
  | list_add       list_add_tail       |              |
  | list_move      list_move_tail      |              |
  | list_del                           |              |
  | list_splice    list_splice_init    |              |
  | list_for_each                      |              |
  | list_entry     list_for_each_entry |              |
  | list_for_each_entry_safe           |              |
* Functions
  
* File

* Introduction to the linux kernel 
  NB:
  This is my first formal,solemn note of reading books.
  I just want to make what have been learned clear. 
  For this purpose, I will make best explain my reading to you via these notes.

  As we all known that Robert love is grand master on kernel hacking.LKD is a nice to get started to linux kernel.

* System calls
  NB:
  Now,11-25-11,you know I need get more knowledge on kernel hacking.
** Get startted
   As we all known,all the hardware machine rescources are on the control of kernel.
   By the reason,if we need the resorce ,we shuold to apply for it to kernel.This is the way,you can do is comply with it. 
   Syscall is a meesenger between applications and the kernel,keep it in mind.
   The reason for the existence of syscall is to provide  a stable system.
   Do you think so?
** Communicating with the kernel
** Syscalls serve 3 primary purposes.
   1.It provides an abstracted hardware interface for user-space.
   2.Middle-man,ensure system security and stability.
   3.Build a foundation to virtualized system provide processes.
** Three legal entry point into kernel
    1.Systemcall
    2.Exceptions
    3.Traps
** API,POSIX,libc
   The manner in which the function is used is not any of the kernel's business.
** Syscall
** System call context
* Kernel data structures
  There are 4 built-in data structures which are all our old friends.
  Linked lists,queues,maps,Binary trees.
** Linked lists
   Singly , doubly ,circular linked list.
   Although the Linux kernelâ€™s linked list implementation is unique, it is fundamentally a
   circular doubly linked list. Using this type of linked list provides the greatest flexibility.
8.     
* Interrupts and interrupt handlers
** Concepts
   1.Interrupt:a mechanism for the hardware to signal to the kernel(in fact,processor) when attention is needed.
   2.Interrupt handlers/interrupt service routine(ISR):the function the kernel runs in response to a specific interrup.
   3.Interrupts: electrical signals,asynchronous interrupts generated by hardware.
   4.Interrupt request(IRQ) line: is assigned a numeric value.
   5.Exceptions:synchronous interrupts,occurs synchronously with respect to the processor clock,
   produced by the processor while executing instructions (traps,syscall)
   either in response to a programming error(divide by zero) 
   or abnormal conditions that must be handled by the kernel(page fault)
   6.Interrupt context/atomic context:code executing in this context is unable to block.
   7.Top half:acknowledging receipt of the interrupt or resetting the hardware.
   8.Reentrancy:interrupt hanlders in linux need not be reentrant.
   9.Interrupt handlers interrupt other code ,possibly even another interrupt handler on a different line!
   10.Intrrupt stack:interrupt handlers's own stack,one stack per processor,one page in size.
** Mechanism
   request_irq:drivers register an interrupt and enable a given interrupt line for handling.
   local_irq_disable:cli
   local_irq_enable:sti
   local_irq_save,local_irq_restore:
   disable_irq,disable_irq_nosync:disable a given interrupt line in the interrupt controller.
   synchronize_irq:waits for a specific interupt handler to exit.
   enable_irq:
   irqs_disabled,in_interrupt,in_irq:
   
*** Execution flow
    Hardware --> Interrupt controller --> Processor --> processor interrupts the kernel --> do_IRQ() --> 
    --> handle_IRQ_event() --> run all interrupt handlers on this line --> ret_from_initr() --> return to the kernel code that was interrupted.
* Bottom halves and deferring work
** Concepts
   1.Bottom halves:the deferred portion of interrupt processing.
   2.Softirq:
   3.Tasklets:
** Mechanism
   open_softirq,raise_softirq:
   struct tasklet_struct

* An introduction to kernel synchronization
** Concepts
   1.Rember to lock data,not code.
   2.Critical regions:code paths that access and manipulate shared data.
   3.Code executes atomically:operations complete without interruption as if the
   entire critical region were one  indivisible instruction.
   4.Race condition:two or more threads of execution to be simultaneously 
   executing within the same critical region.so-named because the threads raced to get there first.

   
** Mechanism
   
* Kernel synchronization methods
** Concepts
   1.Atomic perations:provide instructions that execute atomically without interruption.
   2.Spin lock:can be held by at most one thread execution
   3.Contended:a thread of execution  atempts to acquire a spin lock while it is already held.
   4.Semaphore:sleeping lock.
   5.Life is always a trade-off.
   6.Completion variables: an easy way to synchronize between two tasks in the kernel when 
   one task needs to signal to the other that an event has occurred.
   7.Sequential lock:
** Mechanism
   atomic_t:
  
* Memory management
** FAQ 
   1.Why kernel can't treat all pages as identical in terms of hardware limitations.
   
** Concepts
   1.Page:the kernel treats physical pages as the basic unit of memory management.
   2.MMU:the hardware that manages memory and performs virtual to physical address.
   3.Zone:The kernel uses the zones to group pages of similar properties.
   4.Slab:act as a generic data structure-caching layer.
   5.caches:the slab layer divides different objects into groups.
   6.Interrupt stacks:provide a single per-processor stack used for interrupt handlers.
   7.Kernel stack:minimize your usage,serveral hundred Bytes.
   8.High memory:physical memory that higher 896MB
   9.Logical address:Just offset(3G~3G+896MB) of the physical address,no need to mmu.
   10.Virtual address:(3G~4G).Use mmu to translate it to physical address. 
   11.Per-Cpu data:data that is unique to a given processor.
   11.1.Reasons for using Per-cpu data:reduce lock;reduces cache invalidation.
** Mechanism
   1.Memory access
   alloc_pages,__get_free_pages:allocates contiguous physical pages
   alloc_page,__get_free_page: same to premises.
   get_zeroed_page:page filled with zeros.
   kmalloc:obtaining kernel memory in byte-sized chunks.ultimately alloc_pages.
   vmalloc:only virtually contiguous can be guaranteed,beget TLB trashing
   kmem_getpages:allocate memory sufficient to hold the cache.
   kmem_cache_create:
   kmem_cache_alloc:allocate object from cache.
   kmap:mappings low and high memory on both cpu,permanently.
   kmap_atomic:can use in interrupt handlers.
   get_cpu:get current processor and disable kernel preemption.difference to smp_processor_id().
   put_cpu:enable kernel preemption.

** 
* VFS
** Concepts
   1.VFS:it is the subsystem of the kernel that implements the file and
   filesystem-related interfaces provided to user-space programs.VFS is the
   glue that enables system calls such as open(),read(),and write() to work regardless 
   of the filesystem or underlying physical medium.
   2.Filesystem:is a hierarchical storage of data adhering to a specific structure.
   3.File:is an ordered string of bytes.
   4.Directory:is analogous to a folder and usuallu contains related files.
   Unix,direcories are actually normal files that simply list the files contianed therein.
   5.Directory entry:each component of a path is called a dentry.
   6.inode and file metadata:data about the file's data is stored in a seprate data structure from the file,called the inode.
   7.superblock:stores the filesystem's own control information.
   8.Filesystem metadata:includes information about both the individual files and the filesystem as a whole.
   9.The four primary object types of the VFS are
   9.1.The superblock object, which represents a specific mounted filesystem.
   9.2.The inode object, which represents a specific file.
   9.3.The dentry object, which represents a directory entry, which is a single component of a path.
   9.4.The file object, which represents an open file as associated with a process.
** Mechanism
   struct super_block,inode,dentry,file,file_system_type,vfsmount,files_struct,fs_struct,mnt_namespace.
* The block I/O layer 
** Concepts
   1.Block devices:are hardware devices distinguished by the random access of fixed-size chunks of data.
   2.Blocks:the fixed-size chunks of data.
   3.Character/char device:are accessed as a stream of sequential data,one byte after another.
   4.Sector:the smallest addressable unit on a block device.512B.
   5.Buffer:when a block is stored in memory,it is stored in buffer.
   Each buffer is associated with exactly one block.
   6.Buffer head:the kernel required some associated control information to accompany the data is the descriptor.
** Mechanism
   struct bio:the basic container for block I/O within the kernel.
   struct buffer_head:
* The  process address space
** Concepts
   1.Memory areas:these intervals of legal addresses.
   2.BSS:blcok started by symbol.
   3.Memory descriptor:The kernel represents a process's address space with a data structure.kernel threads do not have a process address space.
   4.Kernel thread:process that have no user context.
   5.Virtual memory areas:the same to memory areas ,in the linux kernel.
   6.Page Tables: that maps virtual pages to physical pages
   7.Page global directory (PGD):
   8.Page middle directory (PMD):
   9.Page table entries (PTE):
   10.Translation lookaside buffer(TLB):
** Mechanism
   find_vma:search for the VMA in which a given memory address resides.
   find_vma_prev:similar to find_vma.
   find_vam_intersection:
   mmap:the function is uesed by the kernel to create a new linear address interval;
   do_map:is the function used to add an address interval to a process's address space.
* The page cache and page writebcak
** Concepts
   Page cache:minimize disk I/O by storing data in physical memory that would otherwise require disk access.
   Page writeback:
   Temporal locality:access to a particular piece of data tends to be clustered in time.
   Backing store:
   Cache hit,Cache miss:
   No write,Write-through cache,Write-back/Copy-back/Write-behind cache:
   Dirty list:datas on disk is dirty -- out of date.
   Cache eviction:selecting clean  pages and simply replacing them with something else.
   Clairvoyant algorithm:Least recnetly used(LRU),Two-list strategy(LRU/2),
   cache cold,cache warm:
   Radix trees:
   Trie:
** Mechanisim
   struct address_space:better name is perhaps page_cache_entity or physical_pages_of_a_file.
   struct address_space_operations:opertions on cache entity.




* Devices and modules
** Concept
   1.Device types:Block devices,Character devices,Network devices.
   2.Blcok devices:support seeking,the random access of data.
   block devices are accessed via a special file called a block device node and 
   generally mounted as a filesystem.
   3.Character device: are accessed via character device node,directly,unlike blcok device.
   4.Network devices:are accessed via socket API not the device node.
   5.Miscellaneous devices:a simplified form of character devices.
   6.Module:a loadable kernel object.
    
* Portability
** Concepts
   1.Word:the amount of data that a machine can process at one time.A word is an integer number of bytes.
   The size of the C long type is guaranteed to be the machine's word size.
   2.LP64:
   3.Naturally aligned:a variable exists at a memory address that is a multiple of its size.
   4.Byte ordering: is the order of bytes within a word.

