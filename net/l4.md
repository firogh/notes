---
tags: net
title: Transport layer
date: 2015-02-27 15:46:13
category: net
---
# RFC
[A Roadmap for Transmission Control Protocol (TCP) Specification Documents](http://tools.ietf.org/html/rfc7414)
[Requirements for Internet Hosts -- Communication Layers](https://tools.ietf.org/html/rfc1122)
[TRANSMISSION CONTROL PROTOCOL 1981](http://tools.ietf.org/html/rfc793)
[RFC Errata 一切都有改口的余地](http://www.rfc-editor.org/errata_search.php?rfc=1122&rec_status=15&presentation=records)
793的errata建议阅读1122.

# 深入理解seq 和ack
[TCP Sequence & Acknowledgment numbers](http://serverfault.com/questions/593037/tcp-sequence-acknowledgment-numbers)
这种问题就是咬住定义就完了.
The sequence number of the first data octet in this segment (except
    when SYN is present). If SYN is present the sequence number is the
    initial sequence number (ISN) and the first data octet is ISN+1.
If the ACK control bit is set this field contains the value of the
    next sequence number the sender of the segment is expecting to
    receive.  Once a connection is established this is always sent.
ACK最简单了, 整个tcp session只有一个segement没有ack number就是第一个syn.
其他情况, ack都是对面发来的seq + len + 1. (排除reorder包问题)
这里的问题是第三次握手的时候, 单独一个ack, 没有数据, 这时候segement的seq
应该是多少呢?RFC给出的是ISN + 1.但这个ack segment是个空数据.
也就出现了下面发一个GET的时seq 和ack number和这个ack segement一致.
那么如果交互过程中出现了空的ack呢?原理和这里是一样的. 空的ack 的seq也是
标志下一个segement的byte序号, 但是如果no data, 下一个segment的seq还是这个.
知道有数据了.
这里想说的是, seq确实是标注segment的data, 知识偶尔因为空ack导致了假象, 会
被后面的有数据的segement还原真相.
总结:
	syn 和 ack, 还有fin这种都不是数据, 不计算在seq里面.
	seq的计算只和实际的数据有关.
	小心处理no data这种情况, 就OK了.

* windowsize 暗含tcp的最大64KB.


#Transport layer -- common
* Multiplexing --  Ports can provide multiple endpoints on a single node. 
inet_hash_connect()
* Encapuslation to segment in skb
	tcp_sendmsg->skb_add_data_nocache()

#TCP -- or some connetion scok
## Componets
### Handshak
* kproxy reorder
chome ->syn(kproxy reocrd syn) -> firoyang.org
firoyang.org ->sync ack -> chrome
chrome -> ack -> firoyang.org
chrome -> GET(firoyang.org) kproxy match then send record syn then setup natinfo ->nginx
nginx -> tcp send fake syn ack->chrome
chrome -> ack -> nginx(then -> firoyang.org)
tcp_v4_do_rcv{
	sk->sk_state == TCP_ESTABLISHED
	tcp_rcv_established{
	len <= tcp_header_len =>
	tcp_ack -> tcp_fastretrans_alert{retrans ack and GET(firoyang) -> nginx
	}
}
nginx->GET ->firoyang.org
firoyang.org->nginx->chrome

### Sliding window protocol
Sliding window protocols are used where reliable in-order delivery of packets is required.
For every ack packet received, the window slides by one packet (logically) to transmit one new packet.
### ARQ
ack and timeout
Sliding window protocol is based on automatic repeat request/ARQ
My conclusion: in practice TCP is a mixture between both GBN and SR.
* Go-Back-N
* Selective repeat

###Congestion control
icsk_ca_ops;
tcp_ack {
tcp_cong_avoid
tcp_fastretrans_alert
tcp_slow_start}
TCP send queue len /proc/sys/net/core/wmem_default

## Services
* Connection-oriented communication -- Session and virtual circuits/in order
* Flow control
* Congestion avoidence
* Detection of transmission errors
Error --  checksum, the transport protocol may check that the data is not corrupted
* Reliability -- assured,Error detection and correction
ACK is an indiction of segments lost.
correction -- Retransmission, ARQ, Automatic repeat request schemes may be used to retransmit lost or corrupted data.
verify correct receipt by sending an ACK or NACK message to the sender.

##FAQ
* What about TCP sequence number warp around
PAWS use timestamp and RTT to solve this problem.
##Timer
*sk_timer
listen: synack
estblished: keepalive
timewait:

##FIXME
* Create TCP options
tcp_syn_build_options()
* Receive ack
tcp_ack()
记录ack的数据大小mss or tcp abc
update snd_wl1 and snd_una
slow path update mtu mss tcp_skb_cb.sacked
* Active send data
tcp_sendpage()/tcp_sendmsg()->tcp_write_xmit()/tcp_push_one()->tcp_transmit_skb
* Timer expiring retransmiter
tcp_retransmiter_timer()...->tcp_transmit_skb()
* reponse for receiving an ACK
tcp_data_snd_check()->tcp_write_xmit()
* tcp_v4_rcv
[skb->dev = NULL;](http://thread.gmane.org/gmane.linux.network/85613/focus=85614)

* seq
貌似syn 报文不算fin算.
当前方向的ack -1 是上一次反方向的seq序列号
