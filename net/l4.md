---
tags: net
title: Transport layer
date: 2015-02-27 15:46:13
category: net
---
# RFC
[A Roadmap for Transmission Control Protocol (TCP) Specification Documents](http://tools.ietf.org/html/rfc7414)
[Requirements for Internet Hosts -- Communication Layers](https://tools.ietf.org/html/rfc1122)
[TRANSMISSION CONTROL PROTOCOL 1981](http://tools.ietf.org/html/rfc793)
[RFC Errata 一切都有改口的余地](http://www.rfc-editor.org/errata_search.php?rfc=1122&rec_status=15&presentation=records)
793的errata建议阅读1122.

# 深入理解seq 和ack
[TCP Sequence & Acknowledgment numbers](http://serverfault.com/questions/593037/tcp-sequence-acknowledgment-numbers)
这种问题就是咬住定义就完了.
The sequence number of the first data octet in this segment (except
    when SYN is present). If SYN is present the sequence number is the
    initial sequence number (ISN) and the first data octet is ISN+1.
If the ACK control bit is set this field contains the value of the
    next sequence number the sender of the segment is expecting to
    receive.  Once a connection is established this is always sent.
ACK最简单了, 整个tcp session只有一个segement没有ack number就是第一个syn.
其他情况, ack都是对面发来的seq + len + 1. (排除reorder包问题)
这里的问题是第三次握手的时候, 单独一个ack, 没有数据, 这时候segement的seq
应该是多少呢?RFC给出的是ISN + 1.但这个ack segment是个空数据.
也就出现了下面发一个GET的时seq 和ack number和这个ack segement一致.
那么如果交互过程中出现了空的ack呢?原理和这里是一样的. 空的ack 的seq也是
标志下一个segement的byte序号, 但是如果no data, 下一个segment的seq还是这个.
知道有数据了.
这里想说的是, seq确实是标注segment的data, 知识偶尔因为空ack导致了假象, 会
被后面的有数据的segement还原真相.
总结:
	syn 和 ack, 还有fin这种都不是数据, 不计算在seq里面.
	seq的计算只和实际的数据有关.
	小心处理no data这种情况, 就OK了.

# windowsize
 暗含tcp的最大64KB.
糊涂窗口指的是接收端的糊涂，而不是发送端的糊涂，接收端不管三七二十一得通告自己的接收窗口大小，丝毫不管这会在发送端产生大量小包。

# Multiplexing
Ports can provide multiple endpoints on a single node. 
inet_hash_connect()

# Connection-oriented communications
## Handshak
* kproxy reorder
chome ->syn(kproxy reocrd syn) -> firoyang.org
firoyang.org ->sync ack -> chrome
chrome -> ack -> firoyang.org
chrome -> GET(firoyang.org) kproxy match then send record syn then setup natinfo ->nginx
nginx -> tcp send fake syn ack->chrome
chrome -> ack -> nginx(then -> firoyang.org)
tcp_v4_do_rcv{
	sk->sk_state == TCP_ESTABLISHED
	tcp_rcv_established{
	len <= tcp_header_len =>
	tcp_ack -> tcp_fastretrans_alert{retrans ack and GET(firoyang) -> nginx
	}
}
nginx->GET ->firoyang.org
firoyang.org->nginx->chrome

# Reliability
## Sliding window protocol
Sliding window protocols are used where reliable in-order delivery of packets is required.
For every ack packet received, the window slides by one packet (logically) to transmit one new packet.
## ARQ
ack and timeout
Sliding window protocol is based on automatic repeat request/ARQ
My conclusion: in practice TCP is a mixture between both GBN and SR.
* Go-Back-N
* Selective repeat

# Congestion control
icsk_ca_ops;
tcp_ack {
tcp_cong_avoid
tcp_fastretrans_alert
tcp_slow_start}
TCP send queue len /proc/sys/net/core/wmem_default

# Flow control
# Detection of transmission errors
Error --  checksum, the transport protocol may check that the data is not corrupted

#FAQ
* What about TCP sequence number warp around
PAWS use timestamp and RTT to solve this problem.
##Timer
*sk_timer
listen: synack
estblished: keepalive
timewait:

## Time wait
[TCP的TIME_WAIT快速回收与重用](http://blog.csdn.net/dog250/article/details/13760985)
双工, 被动关闭收到ack就%100圆满了.而clinet就不能确认被动关闭是否收到ack, 
显然被动关闭方不能在ack了, 如果下去, 还有个完, 所以两害相权, 取其轻.clinet来吧.

1. 为了server考虑, server的session 链接必须别正常正确的关闭!
如果没有time wait, 而且client的ack丢了, server 重传fin ack, clinet的linux
发现这个fin对应的sock不存在, 直接RST, server异常关闭, 应用程序会检测到错误.
不友好.

2. 为了clinet, 不受旧server 干扰.
这也是为什么要等2MSL
* tcp_timestamps tcp_tw_recycle
tcp_time_wait
一起用如果recycle 不ok就是time wait就是TCP_TIMEWAIT_LEN（60s）

两种方法可以进入time wait 状态 tw_substate做区分. 
FIN_WAIT_2 收到fin 见tcp_fin()这个函数
这个, time wait 如果没有设置recycle就是TCP_TIMEWAIT_LEN,设置了就是rto
可以说rto的值真的要比TCP_TIMEWAIT_LEN要小.

FIN_WAIT_2 超时假的time wait状态.貌似tcp_keepalive_timer()
没有遵从协议但是没有break协议,是个优化.
tcp_sock结构占用的资源要比tcp_timewait_sock结构占用的资源多, tcp_done干掉sock.
在TIME_WAIT下也可以处理连接的关闭。
这个,还一样time_wait是和rto TCP_TIMEWAIT_LEN有关.
inet_twsk_schedule设置等的时间. 

* tcp_tw_reuse
貌似很激进.
FIXME
server 端玩蛋去, 本身像80, 自带重用技能...
用在clinet段inet_hash_connect检查是否可以重用TIME_WAIT状态的套接字的端口.

* tcp_fin_timeout
这个参数是FIN_WAIT_2 转到TIME_WAIT的时间.
跟time wait时间, 没有直接联系! 好多blog都直接说成time wait的时间.
这里是间接作用.
FIXME...
而time wait的时间看代码, 要不然是rto 要不然就是TCP_TIMEWAIT_LEN(60s)
tcp_time_wait
                if (recycle_ok) {
                        tw->tw_timeout = rto;     
                } else {
                        tw->tw_timeout = TCP_TIMEWAIT_LEN;
                        if (state == TCP_TIME_WAIT)
                                timeo = TCP_TIMEWAIT_LEN;
                }
如果启用recycle 就是rto, 这个rto是const int rto = (icsk->icsk_rto << 2) - (icsk->icsk_rto >> 1);
3.5倍的icsk_rto

  在FIN_WAIT_2状态下没有接收到FIN包就进入TIME_WAIT的情况下，如果tcp_fin_timeout的值设置的太小，可能会导致TIME_WAIT套接字（子状态为FIN_WAIT_2）过早地被释放，这样对端发送的FIN（短暂地延迟或者本来就是正常的时间到达）到达时就没有办法处理，导致连接不正常关闭，所以tcp_fin_timeout参数的值并不是越小越好，通常设置为30S比较合适。

# optimization
## Nagle
Nagle算法并没有阻止发送小包，它只是阻止了发送大量的小包！
Nagle算法的初衷：避免发送大量的小包，防止小包泛滥于网络，理想情况下，对于一个TCP连接而言，网络上每次只能一个小包存在。它更多的是端到端意义上的优化。
正是交互式应用引入了大量的小包，Nagle算法所作用的正是交互式应用！
## Cork
CORK算法的初衷：提高网络利用率，理想情况下，完全避免发送小包，仅仅发送满包以及不得不发的小包。
CORK的真正初衷是提高载荷率，提高网络利用率

## FIXME
* Create TCP options
tcp_syn_build_options()
* Receive ack
tcp_ack()
记录ack的数据大小mss or tcp abc
update snd_wl1 and snd_una
slow path update mtu mss tcp_skb_cb.sacked
* Active send data
tcp_sendpage()/tcp_sendmsg()->tcp_write_xmit()/tcp_push_one()->tcp_transmit_skb
* Timer expiring retransmiter
tcp_retransmiter_timer()...->tcp_transmit_skb()
* reponse for receiving an ACK
tcp_data_snd_check()->tcp_write_xmit()
* tcp_v4_rcv
[skb->dev = NULL;](http://thread.gmane.org/gmane.linux.network/85613/focus=85614)
